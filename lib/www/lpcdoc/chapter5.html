<html>
<head><title>The Third Age - Lpc-Chapter5</title></head>

<body
background="http://tta.artis.uni-oldenburg.de/~mud/pic/back.jpg"
text="#000000"
link="#701000"
vlink="#406000"
alink="#003300"
>

<a href="http://www.artis.uni-oldenburg.de/tta">
<img border=0 src="http://tta.artis.uni-oldenburg.de/~mud/pic/tta.mini.gif" 
alt="TTA" align=left></a>
<br>
<center>
<h3>The Third Age - An introduction to lpc</h3>
<font size=-1>
<i>(by Descartes of Borg, 23 april 1993)</i>
</font>
</center>
<p>
<hr noshade>

<center>
<h4>
<font color="#007744">
Chapter 5: The Basics of Inheritance
</font>
</h4>
</center>

<h4>5.1 Review</h4>

You should now understand the basic workings of functions.  You should be
able to declare and call one.  In addition, you should be able to recognize
function definitions, although, if this is your first experience with LPC,
it is unlikely that you will as yet be able to define your own functions.
There functions form the basic building blocks of LPC objects.  Code
in them is executed when another function makes a call to them.  In making
a call, input is passed from the calling function into the execution of
the called one.  The called function then executes and returns a value
of a certain data type to the calling function.  Functions which return
no value are of type <i>void</i>.

After examining your workroom code, it might look something like this
(depending on the mudlib):
<pre>
inherit "/base/room";

void
create() 
{
    add_prop("light", 100);
    set_short("Descartes' Workroom");
    set_long("This is where Descartes works.\nIt is a cube.\n");
}
</pre>

If you understand the entire textbook to this point, you should recognize
of the code the following:
<ul>
<li><code>create()</code> is the definition of a function (hey! he did not
declare it) 
<li>It makes calls to <code>add_prop(), set_short()</code>, and
<code>set_long()</code>, none of which are declared or defined in the code.
<li>There is a line at the top that is no variable or function declaration
nor is it a function definition!
</ul>

This chapter will seek to answer the questions that should be in your head
at this point:
<ul>
<li>Why is there no declaration of <code>create()</code>?
<li>Where are the functions <code>add_prop(), set_short()</code>, and
<code>set_long()</code> declared and defined?
<li>What the hell is that line at the top of the file?
</ul>

<h4>5.2 Object oriented programming</h4>

Inheritance is one of the properties which define true object oriented
programming (OOP).  It allows you to create generic code which can be used
in many different ways by many different programs.  What a mudlib does is
create these generalized files (objects) which you use to make very specific
objects.
<p>
If you had to write the code necessary for you to define the workroom above,
you would have to write about 1000 lines of code to get all the functionality
of the room above.  Clearly that is a waste of disk space.  In addition,
such code does not interact well with players and other rooms since every
creator is making up his/her own functions to perform the functionality
of a room.  Thus, what you might use to write out the room's long description,
e.g. <code>query_long()</code>, another wizard might be calling
<code>long()</code>.  This is the primary reason mudlibs are not
compatible, since they use different protocols for object interaction.
<p>
OOP overcomes these problems.  In the above workroom, you inherit the
functions already defined in a file called "/base/room.c".  It has all
the functions which are commonly needed by all rooms defined in it.  When
you get to make a specific room, you are taking the general functionality
of that room file and making a unique room by adding your own function,
<code>create()</code>.

<h4>5.3 How inheritance works</h4>

As you might have guessed by now, the line
<pre>
inherit "/base/room";
</pre>

lets the object inherit the functionality of the room "/base/room.c".  By
inheriting the functionality, it means that you can use the functions which
have been declared and defined in the file "/base/room.c".  In the TTA-Mudlib
"/base/room.c" has, among other functions, <code>add_prop(),
set_short(),</code> and <code>set_long()</code> declared and defined.  In
your function create(), you are making calls to those functions in order to
set values you want your room to start with.  These values make your room
different from others, yet able to interact well with other objects in memory.
<p>
In actual practice, each mudlib is different, and thus requires you to use
a different set of standard functions, often to do the same thing.  It is
therefore beyond the scope of this textbook even to describe what
functions exist and what they do.
<p>
If your mudlib is well documented, however, then you will have tutorials on
how to use the inheritable files to create such objects.  These tutorials
should tell you what functions exist, what input they take, the data
type of their output, and what they do.

<h4>5.4 Chapter summary</h4>

This is far from a complete explanation of the complex subject of inheritance.
The idea here is for you to be able to understand how to use inheritance in
creating your objects.  A full discussion will follow in a later textbook.
Right now you should know the following:
<ul>
<li>Each mudlib has a library of generic objects with their own general
functions used by creators through inheritance to make coding objects
easier and to make interaction between objects smoother.
<li>The functions in the inheritable files of a mudlib vary from mudlib
to mudlib.  There should exist documentation on your mud on how to
use each inheritable file.  If you are unaware what functions are
available, then there is simply no way for you to use them.  Always
pay special attention to the data types of the input and the data
types of ay output.
<li>You inherit the functionality of another object through the line:
<br>
<code>
inherit "filename";
</code>
<br>       
where filename is the name of the file of the object to be inherited.
This line goes at the beginning of your code.
</ul>

<b>Note</b>
<p>
You may see the syntax <code>::create()</code> or <code>::init()</code> in
places.
<p>
You do not need fully to understand at this point the full nuances of this,
but you should have a clue as to what it is. The "::" operator is a way
to call a function specifically in an inherited object (called the scope
resolution operator).  For instance, most muds' room.c has a function
called create().  When you inherit room.c and configure it, you are doing
what is called overriding the create() function in room.c.  This means
that whenever <i>anything</i> calls create(), it will call <i>your</i>
version and not the one in room.c.  However, there may be important stuff
in the room.c version of create().  The :: operator allows you to call the
create() in room.c instead of your create().
<p>
Example 1:
<pre>
inherit "/base/room";

void create() 
{ 
    create();
}
</pre>
Example 2:
<pre>
inherit "/base/room";

void
create() 
{ 
    ::create(); 
}
</pre>

Example 1 includes a bad mistake.  When loaded, the driver calls
<code>create()</code>, and then <code>create()</code> calls
<code>create()</code>, which calls <code>create()</code>, which calls
<code>create()</code>...<p> 
In other words, <code>create()</code> does keep calling itself until the
driver detects a too deep recursion and exits. 

Example 2 is basically just a waste of RAM, as it is not different from room.c
functionally.  With it, the driver calls its <code>create()</code>, which
in turn calls <code>::create()</code>, the originally <code>create()</code>
in room.c.  Otherwise it is functionally exactly the same as room.c.
<p>

<a href="mailto:borg@imaginary.com">George Reese</a> (Descartes of Borg), 
12 july 1993
<p>

<center>
<i><a href="chapter6.html">Next Chapter</a></i>
</center>

<hr noshade>

<address>&#169; <a href="mailto:Markus.Tippmann@informatik.uni-oldenburg.de">manwe</a>, Dec 01, 1996</address>
</body>
</html>
